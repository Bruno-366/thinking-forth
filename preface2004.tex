\chapter*{Preface to the 2004 Edition}
\addcontentsline{toc}{section}{Preface to the 2004 Edition}
\markboth{Preface to the 2004 Edition}{Preface to the 2004 Edition}
\pagestyle{headings}

It is an honor to find myself writing a preface again, twenty years
after the original publication of Thinking \Forth{}. It is gratifying to
know that the concepts covered here still have validity after so many
waves of technology have crested in popularity. These are simply
concepts of good programming, discovered and rediscovered by countless
working developers over the years, and given a fresh twist by a genius
named \person{Chuck Moore}.

I've never claimed to be an expert on comparative language studies. My
recent career has centered more on requirements and functional design
than on development technologies. But with the honor of writing
another preface to this book comes another opportunity to express my
opinion.

In the course of designing Internet applications I've picked up a
little of Java and C\#. Enough to recognize in them glimmers of the
elegance that Chuck has espoused all along, but burdened with
baggage. I looked into some of the recent books that describe design
patterns, assuming that they would address recuring code designs for
real-world phenomenon. Some of the patterns do, like the controller
pattern, but too many others, such as the factory pattern, address
problems that are created by the programming language itself.

In the 1994 Preface, I apologized that my dismissal of
objected-oriented programming in the 1984 edition was a little
overreaching. What motivated that apology was having worked for a time
with an object-oriented flavor of \Forth{} developed by Gary Friedlander
for Digalog Corp. I discovered that the principles of encapsualation
could be applied elegantly to \Forth{} ``objects'' that derived from
classes that each had their own implementation of common methods. The
objects ``knew'' information about themselves, which made code that
called them simpler. But these were still just \Forth{} constructs, and
the syntax was still \Forth{}. It wasn't Java written in \Forth{}. There was
no need for garbage collection, etc. So I won't apologize now for my
apology then, but please know that I didn't mean to sell out in favor
of full-blown object oriented languages.

In the past few years, some people have noted parallels between
Thinking \Forth{} and Extreme Programming. For example, emphasis on
iterative development, incrementally enhancing code that ``works'', and
not over-solving the problem, and so on.

But in my opinion, Extreme Programming seems to miss an important step
in the software development lifecycle: the design of the conceptual
model. With only one or two developers working on a project, this
phase doesn't need to be formalized because good developers do it
intuitively. But in the projects I've been working on, involving five
or more developers, it's crucial.

I define the conceptual model as the representation of how the
software \emph{appears} to work. The conceptual model is not just a
restatement of the requirements. It is the result of carefully
analyzing the top-level requirements and creatively addressing them in
a design that will make sense to the user. An example is the ``shopping
basket'' construct in a commerce application. The conceptual design
forms the basis for a second tier of requirements and drives use cases
describing user/system interactions. This second tier of requirements
definitions then drives the technical design and implemention, or how
the software actually works.

What I've read about Extreme Programming seems to instead assume that
requirements directly drive the implementation. In my career, I've
gravitated to the position of Program Manager, the champion of the
conceptual model. Most software developers I've worked with appreciate
my attention to defining the conceptual model before committing to a
logical and technical design. But the irony in comparing Thinking
\Forth{} with Extreme Programming is that some developers of the XP
stripe (and who of course have never heard of this book) don't even
see the value of a spec!

Ah well.

\begin{flushright}
\emph{May wisdom, fun, and the greater good shine forth in all your work.}

\vspace{2.5em}
\person{Leo Brodie}
\end{flushright}
