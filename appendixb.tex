%% Thinking Forth
%% Copyright (C) 2004 Leo Brodie
%% Initial transcription by Ed Beroset
%% 
%% Chapter: Appendix B, Defining DOER/MAKE
\Chapmark{B}
\chapter{Defining
DOER/MAKE}
\index{D!DOER/MAKE|(}
If your system doesn't have DOER and MAKE
already defined, this appendix
is meant to help you install them and, if necessary, understand
how they work.  Because by its nature this construct is system
dependent, I've included several different implementations at the end of
this appendix in the hope that one of them will work for you.  If no, and if
this section doesn't give you enough information to get them running,
you probably have an unusual system.  Please don't ask me for help; ask
your FORTH vendor.

Here's how it works.  {\bf DOER} is a defining word that creates an entry
with one cell in its parameter field. That cell contains the vector address,
and is initialized to point to a no-op word called {\bf NOTHING}.

Children of {\bf DOER} will execute that {\bf DOES> } code of {\bf DOER}, which
does only two things:  fetch the vector address and place it on the return
stack.  That's all.  FORTH execution then continues with this address on
the return stack, which will cause the vectored function to be performed.
It's like saying (in '83-Standard)
\begin{verbatim}
    ' NOTHING >BODY >R <return>
\end{verbatim}
which executes NOTHING.  (This trick only works with colon definitions.)

Here's an illustration of the dictionary entry created when we enter


{\sf
\bigskip
\begin{tabular}{@{} l l@{}}
DOER JOE & \\
\hline
\vline\ JOE & \vline\ pfa of NOTHING \vline \\
\hline
\ header &\  parameter field
\end{tabular}
\bigskip
}


Now suppose we define:
\begin{verbatim}
    : TEST   MAKE JOE  CR ;
\end{verbatim}
that is, we define a word that can vector JOE to do a carriage return.

Here's a picture of the compiled definition of TEST:  \\
%! This is supposed to be the cell diagram on p. 277, but I just 
%! couldn't figure out how to do it.

{\sf
\begin{tabbing}
XXXXXX \= XXXXXX \= XXXXXX \= XXXXXX \= XXXXXX \= XXXXXX \= \kill
	\> adr of \>	\> adr of \> adr of \> adr of \\
 TEST	\> (MAKE) \> 0  \>  JOE   \>   CR   \>  EXIT \\
header \> \>  MARKER\\
\end{tabbing}
} 

Let's look at the code for {\bf MAKE}.  Since we're using {\bf MAKE} inside a colon
definition, {\bf STATE} will be true, and we'll execut the phrase:
\begin{verbatim}
    COMPILE (MAKE)  HERE MARKER !  0 ,
\end{verbatim}
We can see how {\bf MAKE} has compiled the address of the run-time routine,
{\bf (MAKE)}, followed by a zero.  (We'll explain what the zero is for, and why
we save its address in a the variable {\bf MARKER}, later).  % should probably be "save its address in the variable..."

Now let's look at what {\bf (MAKE)} does when we execute our new 
definition {\bf TEST}:

\bigskip{
\begin{tabular}{lp{.5\textwidth}}
\verb%   R>%		& \parindent-1ex Gets an address from the return stack.
			  This address points to the cell just
			  past {\bf (MAKE)}, where the zero is.\\ 
\verb%   DUP 2+%	& \parindent-1ex Gets the address of the second cell after
			  {\bf (MAKE)}, where the address of {\bf JOE} is.\\
\verb%   DUP 2+%	& \parindent-1ex Gets the address of the third cell after
			  {\bf (MAKE)}, where the cod we want to
			  execute begins.  The stack now has:\\
			& \ (~'marker,~'joe,~'code~--{}--~)\\
\verb%SWAP @ >BODY%	& \parindent-1ex Fetches the contents of the address
			  pointing to JOE (i.e., gets the address 
			  of JOE) and computes JOE's pfa, where
			  the vector address goes.\\
\verb%!%		& \parindent-1ex Stores the address where the new code
			  begins ({\bf CR}, etc.) into the vector
			  address of JOE.
			  Now JOE points inside the definition of
			  TEST.  When we type JOE, we'll do a
			  carriage return.\\
\verb%@ ?DUP IF >R THEN%& \parindent-1ex Fetches the contents of the cell
			  containing zero.  Since the cell does
			  contain zero, the IF THEN statement is
			  not performed.\\
\end{tabular}}
\bigskip

That's the basic idea.  But what about that cell containing zero?  That's
for the use of {\bf ;AND}.  Suppose we changed TEST to read:

\begin{verbatim}
    : TEST   MAKE JOE  CR ;AND SPACE ;
\end{verbatim}
That is, when we invoke TEST we'll vector JOE to do a {\bf CR}, and we'll do a
{\bf SPACE} right now.  Here's what this new version of TEST will look like:
%! The diagram from page 278 is supposed to be here -- I didn't have a 
%! clue, so I just omitted it.

Here's the definition of {\bf ;AND}:
\begin{verbatim}
    : ;AND   COMPILE  EXIT  HERE MARKER @ ! ;   IMMEDIATE
\end{verbatim}
We can see that {\bf ;AND} has compiled an {\bf EXIT}\index{E!EXIT},
just as semicolon would.

Next, recall that {\bf MAKE} saved the address of that cell in a variable
called {\bf MARKER}.  Now {\bf ;AND} stores {\bf HERE} (the location of the second
string of code beginning with {\bf SPACE}) into the cell previously containing
zero.  Now {\bf (MAKE)} has a pointer to the place to resume execution.  The
phrase
\begin{verbatim}
    IF >R THEN
\end{verbatim}
will leave on the return stack the address of the code beginning with 
{\bf SPACE}.  Thus execution will skip over the code between {\bf MAKE} and 
{\bf ;AND} and continue with the remainder of the definition up to semicolon.

The word {\bf UNDO} ticks the name of a {\bf DOER} word, and stores the
address of {\bf NOTHING} into it.

One final note:  on some systems you may encounter a problem.  If
you use {\bf MAKE} outside of a colon definition to create a forward reference,
you may not be able to find the most recently defined word.  For instance,
if you have:
\begin{verbatim}
    : REFRAIN   DO-DAH  DO-DAH ;
    MAKE SONG  CHORUS  REFRAIN ;
\end{verbatim}
your system might think that refrain has not been defined.  The problem
is due to the placement of SMUDGE.  As a solution, try rearranging
the order of definitions or, if necessary, put MAKE code inside a 
definition which you then execute:
\begin{verbatim}
    : SETUP   MAKE SONG  CHORUS  REFRAIN ;   SETUP
\end{verbatim}
In Laboratory Microsystems PC/FORTH 2.0, the UNSMUDGE on line 9 
handles the problem.  This problem does not arrize with the Laxen/Perry/Harris
model.

The final screen is an example of using {\bf DOER/MAKE}.  After loading 
the block, enter
\begin{verbatim}
    RECITAL
\end{verbatim}
then enter 
\begin{verbatim}
    WHY?
\end{verbatim}
followed by return, as many times as you like (you'll get a different
reason each time).

\setcounter{screen}{21}
\begin{Screen}
( DOER/MAKE   Shadow screen                      LPB 12/05/83 )
NOTHING   A no-opp
DOER      Defines a word whose behavior is vectorable.
MARKER    Saves adr for optional continuation pointer.
(MAKE)    Stuffs the address of further code into the
          parameter field of a doer word.
MAKE      Used interpretively:  MAKE doer-name  forth-code ;
          or inside a definition:
             : def   MAKE doer-name  forth-code ;
          Vectors the doer-name word to the forth-code.
;AND      Allows continuation of the "making" definition
UNDO      Usage:  UNDO doer-name ; makes it safe to execute




\end{Screen}
\vfill
\begin{Screen}
\ DOER/MAKE   FORTH-83 Laxen/Perry/Harris model  LPB 12/05/83 
: NOTHING ;
: DOER   CREATE  ['] NOTHING  >BODY ,  DOES> @ >R ;
VARIABLE MARKER
: (MAKE)  R>  DUP 2+  DUP 2+  SWAP @  >BODY !
   @ ?DUP IF >R THEN ;
: MAKE   STATE @ IF ( compiling)
   COMPILE (MAKE)  HERE MARKER !  0 ,
   ELSE  HERE  [COMPILE] '  >BODY !
   [COMPILE] ]  THEN ;   IMMEDIATE
: ;AND   COMPILE EXIT  HERE MARKER @ ! ;   IMMEDIATE
: UNDO   ['] NOTHING  >BODY  [COMPILE] '  >BODY ! ;

\ The code in this screen is in the public domain.


\end{Screen}
\vfill
\begin{Screen}
( DOER/MAKE   FORTH-83 Lab. Micro PC/FORTH 2.0   LPB 12/05/83 )
: NOTHING ;
: DOER   CREATE  ['] NOTHING  >BODY ,  DOES> @ >R ;
VARIABLE MARKER
: (MAKE)  R>  DUP 2+  DUP 2+  SWAP @  >BODY !
   @ ?DUP IF >R THEN ;
: MAKE   STATE @ IF ( compiling)
   COMPILE (MAKE)  HERE MARKER !  0 ,
   ELSE  HERE  [COMPILE] '  >BODY !
   [COMPILE] ] UNSMUDGE  THEN ;   IMMEDIATE
: ;AND   COMPILE EXIT  HERE MARKER @ ! ;   IMMEDIATE
: UNDO   ['] NOTHING  >BODY  [COMPILE] '  >BODY ! ;

( The code in this screen is in the public domain.)


\end{Screen}
\vfill
\begin{Screen}
( DOER/MAKE   FIG model                          LPB 12/05/83 )
: NOTHING   ;
: DOES-PFA  ( pfa -- pfa of child of <BUILD-DOES> )   2+ ;
: DOER   <BUILDS  ' NOTHING ,  DOES> @ >R ;
0 VARIABLE MARKER
: (MAKE)  R>  DUP 2+  DUP 2+  SWAP @  2+ DOES-PFA !
   @ -DUP IF >R THEN ;
: MAKE  STATE @ IF ( compiling)
   COMPILE (MAKE)  HERE MARKER !  0 ,
   ELSE  HERE  [COMPILE] '  DOES-PFA !
   SMUDGE    [COMPILE] ] THEN ; IMMEDIATE
: ;AND   COMPILE ;S  HERE MARKER @ ! ;  IMMEDIATE
: UNDO   ' NOTHING  [COMPILE] '  DOES-PFA ! ;
;S
The code in this screen is in the public domain.

\end{Screen}
\vfill
\begin{Screen}
( DOER/MAKE   79-Standard  MVP FORTH             LPB 12/05/83 )
: NOTHING ;
: DOER   CREATE  ' NOTHING  ,  DOES> @ >R ;
VARIABLE MARKER
: (MAKE)  R>  DUP 2+  DUP 2+  SWAP @  2+ ( pfa) !
   @ ?DUP IF >R THEN ;
: MAKE   STATE @ IF ( compiling)
   COMPILE (MAKE)  HERE MARKER !  0 ,
   ELSE  HERE  [COMPILE] ' !
    [COMPILE] ]  THEN ;   IMMEDIATE
: ;AND   COMPILE EXIT  HERE MARKER @ ! ;   IMMEDIATE
: UNDO   ['] NOTHING  [COMPILE] ' ! ;

( 238 )
( The code in this screen is in the public domain.)

\end{Screen}
\vfill
\begin{Screen}
( TODDLER: Example of DOER/MAKE                     12/01/83 )
DOER WHY?
: RECITAL
  CR ." Your daddy is standing on the table.  Ask him 'WHY?' "
   MAKE WHY? ." To change the light bulb."
  BEGIN
  MAKE WHY?  ." Because it's burned out."
  MAKE WHY?  ." Because it was old."
  MAKE WHY?  ." Because we put it in there a long time ago."
  MAKE WHY?  ." Because it was dark!"
  MAKE WHY?  ." Because it was night time!!"
  MAKE WHY?  ." Stop saying WHY?"
  MAKE WHY?  ." Because it's driving me crazy."
  MAKE WHY?  ." Just let me change this light bulb!"
  F UNTIL ;
: WHY?   CR  WHY?  QUIT ;
\end{Screen}
\index{D!DOER/MAKE|)}
\vfill